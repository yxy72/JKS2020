C51 COMPILER V9.00   MAIN                                                                  09/29/2020 23:02:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files SSD\KeilC51\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************************************************************
   2          
   3          交通科技大赛烧写程序_传感器_单片机_A6模块_云服务器_APP
   4          
   5          ***********************************************************************/
   6          
   7          #include "main.h"
   8          #include "HX711.h"
   9          #include "uart.h"
  10          #include "string.h"
  11          #include <stdio.h>
  12          typedef         unsigned char   u8;
  13          typedef         unsigned int    u16;
  14          typedef         unsigned long   u32;
  15          #define UART1_SendLR() UART1_SendData(0X0D)
  16          #define GapValue 22
  17          #define Buf_Max                   70 
  18          unsigned long HX711_Buffer = 0;
  19          unsigned long Weight_Maopi = 0;
  20          long Weight_Shiwu = 0;
  21          xdata u8 Uart1_Buf[Buf_Max];
  22          unsigned char flag = 0;
  23          bit Flag_ERROR = 0;
  24          idata char server_ip_port_cmd[45];
  25          u8 First_Int = 0;
  26          u16 count_20ms;
  27          
  28          u8 s = '0';
  29          u8* r = "cdd";
  30          
  31          sbit LED1 = P1^0;
  32          sbit LED2 = P1^1;
  33          sbit LED3 = P1^2;
  34          sbit LED4 = P1^3;
  35          sbit LED5 = P1^4;
  36          sbit LED6 = P1^5;
  37          sbit LED7 = P1^6;
  38          sbit LED8 = P1^7;
  39          
  40          
  41          void Timer0Init(void){          //20毫秒@115200
  42   1              TMOD &= 0xF0;           
  43   1              TMOD |= 0x01;           //
  44   1              TL0 = (65536-20000)%256;                //
  45   1              TH0 = (65536-20000)/256;                //
  46   1              TF0 = 0;                //
  47   1              ET0 = 1;          //
  48   1              TR0 = 1;                //开始计时
  49   1      }
  50          void UART1_SendData(u8 dat){
  51   1              ES=0;                   //关串口中断
  52   1              SBUF=dat;                       
  53   1              while(TI!=1);   //等待发送成功
  54   1              TI=0;                   //清除发送中断标志
  55   1              ES=1;                   //开串口中断
C51 COMPILER V9.00   MAIN                                                                  09/29/2020 23:02:55 PAGE 2   

  56   1      }
  57          void CLR_Buf(void){
  58   1              u8 k;
  59   1              for(k=0;k<Buf_Max;k++)      //将缓存内容清零
  60   1              {
  61   2                      Uart1_Buf[k] = 0x00;
  62   2              }
  63   1          First_Int = 0;              //接收字符串的起始存储位置
  64   1      }
  65          
  66          
  67          void delay_ms( ms){
  68   1               count_20ms = ms;
  69   1               while(count_20ms);
  70   1      }
  71          
  72          void Timer0_ISR() interrupt 1{
  73   1              TR0=0;//关定时器
  74   1              TL0 = (65536-20000)%256;                //重设定时器初值
  75   1              TH0 = (65536-20000)/256;                //
  76   1              
  77   1              if(count_20ms > 0) //20ms延时计数器
  78   1              {
  79   2                      count_20ms--;
  80   2              }       
  81   1              
  82   1              TR0=1;//开定时器
  83   1      }
  84          void UART1_ISR (void) interrupt 4{
  85   1              if (RI)
  86   1              {
  87   2                      RI = 0;                           //清除RI位
  88   2                      Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
  89   2                      First_Int++;                      //缓存指针向后移动
  90   2                      if(First_Int >= Buf_Max)          //如果缓存满,将缓存指针指向缓存的首地址
  91   2                      {
  92   3                              First_Int = 0;
  93   3                      }               
  94   2              }
  95   1              if (TI)
  96   1              {
  97   2                      TI = 0;                          //清除TI位
  98   2              }
  99   1      }
 100          void UART1_Send_Command(char *s){
 101   1              CLR_Buf(); 
 102   1              while(*s)//检测字符串结束符
 103   1              {
 104   2                      UART1_SendData(*s++);//发送当前字符
 105   2              }
 106   1          UART1_SendLR();
 107   1              //ART1_SendData('\r');
 108   1              //UART1_SendData('\n');
 109   1      }
 110          
 111          u8 Find(){ 
 112   1      
 113   1              ES = 0;  //改进程序
 114   1              
 115   1              
 116   1      
 117   1              if( strstr(Uart1_Buf,"GV")!=NULL)       
C51 COMPILER V9.00   MAIN                                                                  09/29/2020 23:02:55 PAGE 3   

 118   1              {
 119   2              
 120   2                              r = strstr(Uart1_Buf,"GV");
 121   2                      UART1_Send_Command("？");
 122   2                      LED3 = ~LED3;
 123   2                      ES = 1;
 124   2                      
 125   2      
 126   2              }else if(strstr(Uart1_Buf,"cnb")!=NULL)
 127   1                      LED2 = ~LED2;
 128   1      
 129   1      
 130   1      ES = 1;
 131   1      
 132   1              return 0;
 133   1              
 134   1                      
 135   1      }
 136          
 137          
 138          
 139          
 140          
 141          u8 UART1_Correspond(u8 *b,u16 interval_time)         {
 142   1      
 143   1      
 144   1              CLR_Buf(); 
 145   1      
 146   1              
 147   1              UART1_Send_Command(b);
 148   1              delay_ms(interval_time);
 149   1              Find()  ;
 150   1              return 0;
 151   1      }
 152          
 153          
 154          
 155          
 156          
 157          
 158          void Get_Weight(){
 159   1              Weight_Shiwu = HX711_Read();
 160   1              Weight_Shiwu = Weight_Shiwu - Weight_Maopi;             //获取净重
 161   1              if(Weight_Shiwu > 0)                    
 162   1              {       
 163   2                      Weight_Shiwu = (unsigned int)((float)Weight_Shiwu/GapValue);    //计算实物的实际重量
 164   2                                                                                                                                                      
 165   2                                                                                                                                                      
 166   2                      if(Weight_Shiwu > 100000)               //超重报警
 167   2                      {
 168   3                              Flag_ERROR = 1; 
 169   3                      }
 170   2                      else
 171   2                      {
 172   3                              Flag_ERROR = 0;
 173   3                      }
 174   2              }
 175   1              else
 176   1              {
 177   2                      Weight_Shiwu = 0;
 178   2                      Flag_ERROR = 1;                         //负重报警
 179   2              }
C51 COMPILER V9.00   MAIN                                                                  09/29/2020 23:02:55 PAGE 4   

 180   1              
 181   1      }
 182          
 183          void Get_Maopi(){
 184   1              Weight_Maopi = HX711_Read();    
 185   1      } 
 186          void Delay_ms1(unsigned int n){
 187   1              unsigned int  i,j;
 188   1              for(i=0;i<n;i++)
 189   1                      for(j=0;j<123;j++);
 190   1      }
 191          //****************************************************
 192          //主函数
 193          //****************************************************
 194          void main()     
 195          {
 196   1              char a[7];
 197   1           
 198   1              u8 i;   
 199   1              Timer0Init();
 200   1          Uart_Init();
 201   1      //      Get_Maopi();                            //称毛皮重量
 202   1              EA = 1;      //开启总中断
 203   1              for(i = 0;i < 30;i++)//等待网络稳定
 204   1              {
 205   2                      delay_ms(50);
 206   2              }
 207   1      
 208   1      
 209   1              a[0]='0';
 210   1              a[1]='6';
 211   1              a[2]=(0X30);
 212   1              a[3]=(0X30);
 213   1              a[5]=(0X30);
 214   1              a[6]=(0X30);
 215   1              a[4]='.';
 216   1              //a[5]='\n';    
 217   1      
 218   1              while(1)
 219   1              {
 220   2              //      EA = 0;
 221   2              //      Get_Weight();                   
 222   2              //      EA = 1;
 223   2                      LED1 = ~LED1;
 224   2              /*      if( Flag_ERROR == 1)
 225   2                      {
 226   2                 UART1_Send_Command("0600.00");
 227   2                      }               
 228   2                      else
 229   2                      {                               
 230   2                              a[2]=(Weight_Shiwu/10000 + 0X30);
 231   2                  a[3]=(Weight_Shiwu%10000/1000 + 0X30);
 232   2                  a[5]=(Weight_Shiwu%1000/100 + 0X30);        
 233   2                  a[6]=(Weight_Shiwu%100/10 + 0X30);  
 234   2                      
 235   2                              UART1_Send_Command(a);
 236   2                      }  
 237   2      
 238   2                */
 239   2              //      UART1_Send_Command(r)   ;
 240   2                      UART1_Correspond(r,50);
 241   2              //      UART1_Send_Command("cnd")        ;
C51 COMPILER V9.00   MAIN                                                                  09/29/2020 23:02:55 PAGE 5   

 242   2      
 243   2      
 244   2                      Delay_ms1(2000);        
 245   2              }       
 246   1      }
 247          
 248          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    542    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =     70    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      10
   IDATA SIZE       =     45    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
